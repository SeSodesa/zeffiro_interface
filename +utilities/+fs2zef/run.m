function run(segmentation_output_folder, recon_all_output_folder, kwargs)
%
% fs2zef.run (segmentation_output_folder, recon_all_output_folder, kwargs)
%
% Uses the external program FreeSurfer to generate a segmentation, that can
% then be imported to Zeffiro interface. Optionally, a [FreeSurfer]
% reconstruction can also be performed via the program [recon-all]. This
% function is invoked with
%
%   utilities.fs2zef.run(segmentation_output_folder, recon_all_output_folder , kwargs)
%
% in the zeffiro_interface root folder. The segmentation output folder needs
% to exist when this function is started, in addition to the recon-all input
% file, if the third argument is given.
%
% Inputs:
%
% - segmentation_output_folder (1,1) string { mustBeFolder }
%
%   This is the folder that the segmentaion ASCII files will be written to. It
%   needs to exist before this function is called.
%
% - recon_all_output_folder (1,1) string
%
%   The folder that contains the reconstruction files generated by the
%   FreeSurfer program [recon-all].
%
%   NOTE: If recon-all IS invoked via the argument kwargs.recon_all_input_files, this
%   folder does not need to exist when this function is called, as recon-all
%   generates it for you under the parent directory of the given path. If
%   recon-all is NOT invoked, it is assumed that this given folder directly
%   contains the output files of recon-all.
%
% - kwargs.recon_all_input_files (:,1) string = string([])
%
%   If one wishes to run the recon-all process for an MRI image, as in a
%   single NIFTI (.nii) file, or one or multiple DICOM (.dcm) files, the file
%   paths should be provided in this string array. The output of recon-all
%   will be placed in recon_all_output_folder.
%
%   NOTE: the provided recon_all_output_folder must NOT exist, if this
%   argument is provided, as recon-all creates it for you. The parent folder
%   of recon_all_output_folder MUST exist in any case.
%
% - kwargs.electrode_file = "electrodes.dat"
%
%   The file from which the electrodes are read. By default, it is the one
%   found in this folder, but alternative ones may be used via this argument.
%
% - kwargs.import_script_file = "import_segmentation.zef"
%
%   The import_segmentation.zef file one wishes to use in importing the
%   generated segmentation into Zeffiro Interface.
%
% Outputs:
%
% This function does not return anything, but will throw an error, if one of
% the programs that is invoked via the system shell returns with an exit code
% indicating an error. If an error is thrown, the error message emitted by the
% called FreeSurfer function will be printed.
%
% Links:
%
% [FreeSurfer]: https://surfer.nmr.mgh.harvard.edu/
%
% [recon-all]: https://surfer.nmr.mgh.harvard.edu/fswiki/recon-all
%

    arguments

        segmentation_output_folder (1,1) string { mustBeFolder }

        recon_all_output_folder (1,1) string

        kwargs.recon_all_input_files (:,1) string { mustBeFile } = string([])

        kwargs.electrode_file (1,1) string { mustBeFile } = fullfile ( this_folder, "electrodes.dat" )

        kwargs.import_script_file (1,1) string { mustBeFile } = fullfile ( this_folder, "import_segmentation.zef" )

    end

    % Resolve relative paths and such.

    segmentation_output_folder = fullfile ( segmentation_output_folder ) ;

    recon_all_output_folder = fullfile ( recon_all_output_folder ) ;

    kwargs.recon_all_input_files = arrayfun ( @fullfile, kwargs.recon_all_input_files ) ;

    %% Perform initial checks to make sure all environment variables and such are in place.

    FREESURFER_HOME = getenv ( "FREESURFER_HOME" ) ;

    variable_set = not ( strlength ( FREESURFER_HOME ) == 0 ) ;

    variable_not_set = not ( variable_set ) ;

    if variable_not_set

        error ( "The environment variable FREESURFER_HOME was not set, or it was empty. Please point it to the FreeSurfer installation directory." ) ;

    end

    if not ( isfolder ( FREESURFER_HOME ) )

        error ( "The FreeSurfer environment variable FREESURFER_HOME is not pointing to an existing directory. Please point it to the FreeSurfer installation directory." ) ;

    end

    FREESURFER_BIN = fullfile(FREESURFER_HOME, "bin");

    if not ( isfolder ( FREESURFER_BIN ) )

        error("Could not find the folder " + FREESURFER_BIN + " with the FreeSurfer binaries. Was FreeSurfer installed correctly?") ;

    end

    freesurfer_env(FREESURFER_HOME, FREESURFER_BIN);

    %% Run recon-all, if input file was specified and exists.

    [out_folder_parent, out_folder_name, ~] = fileparts(recon_all_output_folder);

    FSF_OUTPUT_FORMAT = getenv ( "FSF_OUTPUT_FORMAT" ) ;

    if strlength ( FSF_OUTPUT_FORMAT ) == 0

        FSF_OUTPUT_FORMAT = ".nii.gz" ;

    end

    if not ( isempty ( kwargs.recon_all_input_files ) )

        disp(newline + "Attempting to run recon-all on " + kwargs.recon_all_input_files + "…");

        if not ( isfolder ( out_folder_parent ) )

            error("When invoking recon-all, the specified output folder should have a parent folder. Aborting...")

        end

        % Construct recon-all command from given file paths.

        recon_all_cmd = "recon-all" ;

        for fpath = kwargs.recon_all_input_files

            if not ( isfile ( fpath ) )

                error("Given recon-all input file (" + fpath + ") does not exist or is not a file. Aborting...")

            end

            if ( endsWith ( fpath, ".nii" ) || endsWith ( fpath, ".nii.gz" ) ) && numel ( kwargs.recon_all_input_files ) == 1

                recon_all_cmd = recon_all_cmd + " -i " + fpath ;

            elseif endsWith ( fpath, ".dcm" ) || endsWith ( fpath, ".dcm.gz" )

                recon_all_cmd = recon_all_cmd + " -i " + fpath ;

            elseif endsWith ( fpath, FSF_OUTPUT_FORMAT )

                if contains ( fpath, ".nii" ) && numel ( kwargs.recon_all_input_files ) == 1

                    recon_all_cmd = recon_all_cmd + " -i " + fpath ;

                elseif contains ( fpath, ".dcm" )

                    recon_all_cmd = recon_all_cmd + " -i " + fpath ;

                else

                    error("Either there were more than one NIFTI (.nii) files in the set of recon-all input files, or the given input file (" + fpath + ") was not a DICOM (.dcm) file. Aborting...") ;

                end % if

            else

                error("Either there were more than one NIFTI (.nii) files in the set of recon-all input files, or the given input file (" + fpath + ") was not a DICOM (.dcm) file. Aborting...") ;

            end % if

        end % for

        % Add other needed flags to the command.

        recon_all_cmd = recon_all_cmd ...
            + " -s " + out_folder_name ...
            + " -sd " + out_folder_parent ...
            + " -all" ;

        % Run the constructed command.

        run_and_print_command(recon_all_cmd);

        disp(newline + "Done. recon-all output is in " + recon_all_output_folder + ".");

    end % if

    %% Check the existence of all required binaries.

    mris_convert = fullfile(FREESURFER_BIN, "mris_convert");

    mri_mc = fullfile(FREESURFER_BIN, "mri_mc");

    mri_watershed = fullfile(FREESURFER_BIN, "mri_watershed");

    mri_annotation2label = fullfile(FREESURFER_BIN, "mri_annotation2label");

    mri_mergelabels = fullfile(FREESURFER_BIN, "mri_mergelabels");

    required_binaries = [ mris_convert, mri_mc, mri_watershed, mris_convert, mri_annotation2label, mri_mergelabels ] ;

    for bin = required_binaries

        if not ( isfile ( bin ) )

            error(newline + "Could not locate the required FreeSurfer program " + bin + ". Aborting...")

        end % if

    end % for

    %% Generate segmentation.

    disp(newline + "Generating segmentation into " + segmentation_output_folder + "…");

    % 1. Convert any surfaces to ASCII files.

    surf_path = fullfile(recon_all_output_folder, "surf");

    if not ( isfolder ( surf_path ) )

        error("There was no surface reconstruction in " + surf_path + ". Aborting…");

    end

    cmd1 = mris_convert + " " + fullfile(surf_path, "lh.pial") + " " + fullfile(segmentation_output_folder, "lh.pial.asc");

    cmd2 = mris_convert + " " + fullfile(surf_path, "rh.pial") + " " + fullfile(segmentation_output_folder, "rh.pial.asc");

    cmd3 = mris_convert + " " + fullfile(surf_path, "lh.white") + " " + fullfile(segmentation_output_folder, "lh.wm.asc");

    cmd4 = mris_convert + " " + fullfile(surf_path, "rh.white") + " " + fullfile(segmentation_output_folder, "rh.wm.asc");

    run_and_print_command(cmd1);

    run_and_print_command(cmd2);

    run_and_print_command(cmd3);

    run_and_print_command(cmd4);

    % 2. Extract subcortical structures.

    mri_input_path = fullfile(recon_all_output_folder, "mri", "aseg.mgz");

    if not ( isfile ( mri_input_path ) )

        error("There was no mri reconstruction in " + mri_input_path + ". Aborting…");

    end

    compartment_numbers = [
        4; 5; 7; 8; 10; 11; 12; 13; 14; 15; 16; 17; 18; 26; 28; 30; 31; 43;
        44; 46; 47; 49; 50; 51; 52; 53; 54; 58; 60; 62; 63; 251; 252; 253;
        254; 255;
    ];

    compartment_names = [
        "lh_Lateral-Ventricle"; "lh_Inf-Lat-Vent"; "lh_CerebellumWM";
        "lh_CerebellumCortex"; "lh.thalamus"; "lh.caudate"; "lh.putamen";
        "lh.pallidum"; "3rd-Ventricle"; "4th-Ventricle"; "Brainstem";
        "lh.Hippocampus"; "lh.Amygdala"; "lh.Accumbens"; "LVentral_DC";
        "LVessel"; "LChoroid_plexus"; "rh_Lateral-Ventricle";
        "rh_Inf-Lat-Vent"; "rh_CerebellumWM"; "rh_CerebellumCortex";
        "rh.thalamus"; "rh.caudate"; "rh.putamen"; "rh.pallidum";
        "rh.Hippocampus"; "rh.Amygdala"; "rh.Accumbens"; "RVentral_DC";
        "RVessel"; "RChoroid_plexus"; "CC_posterior"; "CC_Mid_posterior";
        "CC_Central"; "CC_Mid_Anterior"; "CC_Anterior";
    ];

    assert ( numel(compartment_numbers) == numel(compartment_names) );

    for ii = 1 : numel(compartment_numbers)

        cnum = compartment_numbers(ii);

        cname = compartment_names(ii);

        out_path = fullfile(segmentation_output_folder, cname) + ".asc";

        cmd = mri_mc + " " + mri_input_path + " " + cnum + " " + out_path;

        run_and_print_command(cmd, false);

    end % for

    % 3. Extracting the skull and other outer non-brain tissues.

    orig_nu_path = fullfile(recon_all_output_folder, "mri", "orig_nu.mgz");

    if not ( isfile ( orig_nu_path ) )

        error("Did not find " + orig_nu_path + ". Aborting…");

    end

    trash_path = fullfile(recon_all_output_folder, "trash", "trash.mgz");

    cmd = mri_watershed + " -useSRAS -surf " + surf_path  + " " + orig_nu_path + " " + trash_path;

    run_and_print_command(cmd);

    if not ( isfile ( trash_path ) )

        error("Did not find " + trash_path + ". Aborting…");

    end

    cmd = mris_convert ...
        + " " ...
        + fullfile(recon_all_output_folder, "surf_outer_skin_surface") ...
        + " " ...
        + fullfile(segmentation_output_folder, "outer_skin.asc");

    run_and_print_command(cmd);

    cmd = mris_convert ...
        + " " ...
        + fullfile(recon_all_output_folder, "surf_outer_skull_surface") ...
        + " " ...
        + fullfile(segmentation_output_folder, "outer_skull.asc");

    run_and_print_command(cmd);

    cmd = mris_convert ...
        + " " ...
        + fullfile(recon_all_output_folder, "surf_inner_skull_surface") ...
        + " " ...
        + fullfile(segmentation_output_folder, "inner_skull.asc");

    run_and_print_command(cmd);

    % 4. Cortical parcellation (.annot files).
    %
    % After Freesurfer processes a subject, in the subject's /label directory,
    % there are .annot files containing the parcellation data for each
    % hemishere.
    %
    % - ?h.aparc.annot files contain the desikan_killiany.gcs parcellation scheme % (36 labels)
    % - ?h.aparc.a2009s.annot files contain the destrieux.simple.2009-07-28.gcs % scheme (76 labels)
    % - ?h.aparc.DKTatlas.annot correspond to the DKTatas40.gcs scheme
    %

    outdir = fullfile(segmentation_output_folder, "lh.aparc_76") ;

    cmd = mri_annotation2label ...
        + " --subject " + out_folder_name ...
        + " --sd " + out_folder_parent ...
        + " --annotation aparc.a2009s" ...
        + " --hemi lh " ...
        + " --ctab aparc.annot.a2009s" ...
        + " --outdir " + outdir ;

    run_and_print_command(cmd);

    outdir = fullfile(segmentation_output_folder, "rh.aparc_76") ;

    cmd = mri_annotation2label ...
        + " --subject " + out_folder_name ...
        + " --sd " + out_folder_parent ...
        + " --annotation aparc.a2009s" ...
        + " --hemi rh " ...
        + " --ctab aparc.annot.a2009s" ...
        + " --outdir " + outdir ;

    run_and_print_command(cmd);

    outdir = fullfile(segmentation_output_folder, "lh.aparc_36") ;

    cmd = mri_annotation2label ...
        + " --subject " + out_folder_name ...
        + " --sd " + out_folder_parent ...
        + " --annotation aparc" ...
        + " --hemi lh " ...
        + " --ctab aparc.annot" ...
        + " --outdir " + outdir ;

    run_and_print_command(cmd);

    outdir = fullfile(segmentation_output_folder, "rh.aparc_36") ;

    cmd = mri_annotation2label ...
        + " --subject " + out_folder_name ...
        + " --sd " + out_folder_parent ...
        + " --annotation aparc" ...
        + " --hemi rh " ...
        + " --ctab aparc.annot" ...
        + " --outdir " + outdir ;

    run_and_print_command(cmd);

    % 5. Create Matlab-compatible colortables.

    utilities.fs2zef.save_color_tables(recon_all_output_folder, segmentation_output_folder);

    % 6. Merge labels.

    cmd = mri_mergelabels ...
        + " -d " + fullfile(segmentation_output_folder, "lh.aparc_76") ...
        + " -o " + fullfile(segmentation_output_folder, "lh_labels_76.asc") ;

    run_and_print_command(cmd);

    cmd = mri_mergelabels ...
        + " -d " + fullfile(segmentation_output_folder, "rh.aparc_76") ...
        + " -o " + fullfile(segmentation_output_folder, "rh_labels_76.asc") ;

    run_and_print_command(cmd);

    cmd = mri_mergelabels ...
        + " -d " + fullfile(segmentation_output_folder, "lh.aparc_36") ...
        + " -o " + fullfile(segmentation_output_folder, "lh_labels_36.asc") ;

    run_and_print_command(cmd);

    cmd = mri_mergelabels ...
        + " -d " + fullfile(segmentation_output_folder, "rh.aparc_36") ...
        + " -o " + fullfile(segmentation_output_folder, "rh_labels_36.asc") ;

    run_and_print_command(cmd);

    disp("  Saving .dat files…")

    utilities.fs2zef.save_dats(segmentation_output_folder);

    %% Copy files to target location.

    disp(newline + "Copying files…" + newline);

    disp("  electrodes.dat…");

    function_file = mfilename("fullpath");

    [parent_folder, ~, ~] = fileparts(function_file);

    electrode_file = fullfile ( kwargs.electrode_file ) ;

    if isfile ( electrode_file )

        copyfile(electrode_file, fullfile(segmentation_output_folder, "electrodes.dat"));

    else

        warning("  Could not find " + electrode_file + "…");

    end

    disp("  import_segmentation.zef…");

    import_script_file = fullfile( kwargs.import_script_file );

    if isfile ( import_script_file )

        copyfile(import_script_file, fullfile(segmentation_output_folder, "import_segmentation.zef"));

    else

        warning("  Could not find " + import_script_file + "…");

    end

    disp(newline + "Done.")

end % function

%% Private helper functions.

function [exitcode, out] = run_and_print_command(cmd, throw_err)
%
% run_and_print_command
%
% Runs a given command through the system function, and checks for the exit
% code. If the exit code is not 0, shows the output of the failed commmand
% either as an error, of if throw_err is set to false, as a warning. This
% gives the called the option of handling the problem without terminating the
% program.
%
% Inputs:
%
% - cmd (1,1) string
%
%   The command string that is to be fed to system.
%
% - throw_err (1,1) logical = true
%
%   If this is set to true, an error with the message is thrown.
%
% Outputs:
%
% - exitcode
%
%   The exit code of the program that system ran.
%
% - out
%
%   The output of the program.
%

    arguments

        cmd (1,1) string

        throw_err (1,1) logical = true

    end

    disp(newline + ">>> " + cmd);

    [exitcode, out] = system(cmd);

    if not ( exitcode == 0 )

        message = newline ...
            + "Running the command failed. Displaying output:" ...
            + newline ...
            + join ( repmat ( "-", 1, 79 ), "" ) ...
            + newline ...
            + out ...
            + newline ...
            + join ( repmat ( "-", 1, 79 ), "" ) ;

        if throw_err

            error(message);

        else

            warning(message);

        end % if

    end % if

end % function

function check_freesurfer_env_variable(variable_name, FREESURFER_HOME, FS_OVERRIDE)
%
% check_freesurfer_env_variable
%
% Defines how each FreeSurfer environment variable should be handled, based on
% $FREESURFER_HOME/FreeSurferEnv.sh.
%
% Inputs:
%
% - variable_name
%
%   The name of the environment variable being checked.
%
% - FREESURFER_HOME
%
%   The installation directory of FreeSurfer.
%
% - FS_OVERRIDE
%
%   The value of this logical FreeSurfer Evironment variable determines,
%   whether the default FreeSurfer folder locations are to be attempted, if
%   fetching the value of the above variable_name does not point to a valid
%   value.
%
% Outputs:
%
% - None.
%
%   An error is thrown if the given variable is not or cannot be set
%   appropriately.
%

arguments

    variable_name (1,1) string

    FREESURFER_HOME (1,1) string { mustBeFolder }

    FS_OVERRIDE (1,1) logical

end

    % Define certain top level variables.

    variable_value = getenv ( variable_name ) ;

    variable_set = not ( strlength ( variable_value ) == 0 ) ;

    variable_not_set = not ( variable_set ) ;

    does_not_exist_msg = "The FreeSurfer variable " + variable_name + " was not set or is empty. Please point it to the location indicated by FreeSurfer documentation." ;

    is_not_folder_message = "The FreeSurfer variable " + variable_name + " has the value (" + variable_value + "), which is not a folder as it is supposed to be." ;

    % Go over possible FreeSurfer environment variables.

    if variable_name == "FREESURFER_HOME"

        if variable_not_set

            error ( does_not_exist_msg ) ;

        end

        if not ( isfolder ( variable_value ) )

            error ( is_not_folder_message ) ;

        end

        build_stamp_path = fullfile(variable_value, "build-stamp.txt");

        if not ( isfile ( build_stamp_path ) )

            warning("The file " + build_stamp_path + " does not exist. Is FreeSurfer installed correctly?" ) ;

        end

    elseif variable_name == "FREESURFER"

        if variable_not_set

            setenv("FREESURFER", FREESURFER_HOME)

        end

    elseif variable_name == "SUBJECTS_DIR"

        if variable_not_set && FS_OVERRIDE

            variable_value = fullfile(FREESURFER_HOME, "subjects");

            setenv("SUBJECTS_DIR", variable_value);

        end

        if not ( isfolder ( variable_value ) )

            error("The directory " + variable_value + " pointed to by " + variable_name + " does not exist under the FreeSurfer installation directory, as it is supposed to.") ;

        end

    elseif variable_name == "FSFAST_HOME"

        if variable_not_set && FS_OVERRIDE

            variable_value = fullfile(FREESURFER_HOME, "fsfast");

            setenv("FSFAST_HOME", variable_value);

        end

        if not ( isfolder ( variable_value ) )

            error("The directory " + variable_value + " pointed to by " + variable_name + " does not exist under the FreeSurfer installation directory, as it is supposed to.") ;

        end

    elseif variable_name == "MNI_DIR"

        % Get environment variables relevant to MNI.

        NO_MINC = getenv ( "NO_MINC" ) ;

        MINC_BIN_DIR = getenv ( "MINC_BIN_DIR" ) ;

        MINC_LIB_DIR = getenv ( "MINC_LIB_DIR" ) ;

        MNI_DATAPATH = getenv ( "MNI_DATAPATH" ) ;

        MNI_INSTALL_DIR = getenv ( "MNI_INSTALL_DIR" ) ;

        % Check whether the variables are set.

        NO_MINC_SET = not( strlength(NO_MINC) == 0 ) ;

        MINC_BIN_DIR_SET = not ( strlength(MINC_BIN_DIR) == 0 ) ;

        MINC_LIB_DIR_SET = not ( strlength(MINC_LIB_DIR) == 0 ) ;

        MNI_DATAPATH_SET = not ( strlength(MNI_DATAPATH) == 0 ) ;

        MNI_INSTALL_DIR_SET = not ( strlength(MNI_INSTALL_DIR) == 0 ) ;

        % Set possible default locations for MNI directories.

        default_mni_dir = fullfile(FREESURFER_HOME, "mni") ;

        default_minc_bin_dir = fullfile( default_mni_dir, "bin" ) ;

        default_minc_lib_dir = fullfile( default_mni_dir, "lib" ) ;

        default_minc_data_dir = fullfile( default_mni_dir, "data" ) ;

        default_pubsw_mni_dir = fullfile("/", "pubsw", "packages", "mni", "current") ;

        default_pubsw_minc_bin_dir = fullfile(default_pubsw_mni_dir, "bin") ;

        default_pubsw_minc_lib_dir = fullfile(default_pubsw_mni_dir, "lib") ;

        default_pubsw_minc_data_dir = fullfile(default_pubsw_mni_dir, "data") ;

        default_local_pubsw_mni_dir = fullfile("/", "usr", "local", "pubsw", "packages", "mni", "current");

        default_local_pubsw_minc_bin_dir = fullfile(default_local_pubsw_mni_dir, "bin");

        default_local_pubsw_minc_lib_dir = fullfile(default_local_pubsw_mni_dir, "lib");

        default_local_pubsw_minc_data_dir = fullfile(default_local_pubsw_mni_dir, "data");

        default_local_mni_dir = fullfile("/", "usr", "local", "mni");

        default_local_minc_bin_dir = fullfile(default_local_mni_dir, "bin");

        default_local_minc_lib_dir = fullfile(default_local_mni_dir, "lib");

        default_local_minc_data_dir = fullfile(default_local_mni_dir, "data");

        % Check whether the MINC toolkit binary folders exist in one of the
        % default locations, if the directories were not set via environment.

        if NO_MINC_SET && ( not ( MINC_BIN_DIR_SET ) || FS_OVERRIDE )

            if MNI_INSTALL_DIR_SET && isfolder ( MNI_INSTALL_DIR )

                setenv("MINC_BIN_DIR", fullfile(MNI_INSTALL_DIR, "bin"));

                setenv("MNI_DIR", fullfile(MNI_INSTALL_DIR));

            elseif isfolder ( default_mnic_bin_dir )

                setenv("MINC_BIN_DIR", default_minc_bin_dir);

                setenv("MNI_DIR", default_mni_dir);

            elseif isfolder ( default_pubsw_mnic_bin_dir )

                setenv("MINC_BIN_DIR", default_pubsw_minc_bin_dir);

                setenv("MNI_DIR", default_pubsw_mni_dir);

            elseif isfolder ( default_local_pubsw_mnic_bin_dir )

                setenv("MINC_BIN_DIR", default_local_pubsw_minc_bin_dir);

                setenv("MNI_DIR", default_local_pubsw_mni_dir);

            elseif isfolder ( default_local_mnic_bin_dir )

                setenv("MINC_BIN_DIR", default_local_minc_bin_dir);

                setenv("MNI_DIR", default_local_mni_dir);

            else

                warning(newline + "MINC_BIN_DIR might not be set correctly. Is the FreeSurfer MNI toolkit installed on the system?")

            end % if

        end % if

        % Check whether the MINC toolkit library folders exist in one of the
        % default locations, if the directories were not set via environment.

        if not ( NO_MINC_SET ) && ( not ( MINC_LIB_DIR_SET ) || FS_OVERRIDE )

            if MNI_INSTALL_DIR_SET && isfolder ( MNI_INSTALL_DIR )

                setenv("MINC_LIB_DIR", fullfile(MINC_LIB_DIR, "lib"));

                setenv("MNI_DIR", fullfile(MNI_INSTALL_DIR));

            elseif isfolder ( default_minc_lib_dir )

                setenv("MINC_LIB_DIR", default_minc_lib_dir);

                setenv("MNI_DIR", default_mni_dir);

            elseif isfolder ( default_pubsw_mnic_lib_dir )

                setenv("MINC_LIB_DIR", default_pubsw_minc_lib_dir);

                setenv("MNI_DIR", default_pubsw_mni_dir);

            elseif isfolder ( default_local_pubsw_mnic_lib_dir )

                setenv("MINC_LIB_DIR", default_local_pubsw_minc_lib_dir);

                setenv("MNI_DIR", default_local_pubsw_mni_dir);

            elseif isfolder ( default_local_mnic_lib_dir )

                setenv("MINC_LIB_DIR", default_local_minc_lib_dir);

                setenv("MNI_DIR", default_local_mni_dir);

            else

                warning(newline + "MINC_LIB_DIR might not be set correctly. Is the FreeSurfer MNI toolkit installed on the system?")

            end % if

        end % if

        % Check whether the MNI toolkit data folders exist in one of the
        % default locations, if the directories were not set via environment.

        if not ( NO_MINC_SET ) && ( not ( MNI_DATAPATH_SET ) || FS_OVERRIDE )

            if MNI_INSTALL_DIR_SET && isfolder ( MNI_INSTALL_DIR )

                setenv("MNI_DATAPATH", fullfile(MNI_INSTALL_DIR, "data"));

            elseif isfolder ( default_minc_data_dir )

                setenv("MNI_DATAPATH", default_minc_data_dir);

            elseif isfolder ( default_pubsw_mnic_data_dir )

                setenv("MNI_DATAPATH", default_pubsw_mnic_data_dir);

            elseif isfolder ( default_local_pubsw_mnic_data_dir )

                setenv("MNI_DATAPATH", default_local_pubsw_mnic_data_dir);

            elseif isfolder ( default_local_mnic_data_dir )

                setenv("MNI_DATAPATH", default_local_mnic_data_dir);

            else

                warning(newline + "MNI_DATAPATH might not be set correctly. Is the FreeSurfer MNI toolkit installed on the system?")

            end % if

        end % if

    elseif variable_name == "FSL_DIR"

        % Check relevant environment variables.

        FSL_DIR = getenv ( "FSL_DIR" ) ;

        FSL_DIR_SET = not ( strlength ( FSL_DIR ) == 0 );

        % Default paths FSL might be installed in.

        default_fsl_dir = fullfile(FREESURFER_HOME, "fsl");

        default_pubsw_fsl_dir = fullfile("/", "usr", "pubsw", "packages", "fsl", "current");

        default_local_pubsw_fsl_dir = fullfile("/", "usr", "local", "pubsw", "packages", "fsl", "current");

        default_local_fsl_dir = fullfile("/", "usr", "local", "fsl");

        % Check default paths if needed.

        if not( FSL_DIR_SET ) || FS_OVERRIDE

            if FSL_DIR_SET

                setenv("FSL_DIR", fullfile(FSL_DIR))

            elseif isfolder ( default_fsl_dir )

                setenv ( "FSL_DIR", default_fsl_dir ) ;

            elseif isfolder ( default_pubsw_fsl_dir )

                setenv ( "FSL_DIR", default_pubsw_fsl_dir ) ;

            elseif isfolder ( default_local_pubsw_fsl_dir )

                setenv ( "FSL_DIR", default_pubsw_fsl_dir ) ;

            elseif isfolder ( default_local_fsl_dir )

                setenv ( "FSL_DIR", default_local_fsl_dir ) ;

            else

                warning(newline + "FSL_DIR is not set, so FSL seems to not be installed. See https://surfer.nmr.mgh.harvard.edu/fswiki/FSL for details.")

            end % if

        end % if

    elseif variable_name == "FSF_OUTPUT_FORMAT"

        if variable_not_set && FS_OVERRIDE

            setenv("FSF_OUTPUT_FORMAT", "nii.gz") ;

        end

    elseif variable_name == "FUNCTIONALS_DIR"

        if variable_not_set && FS_OVERRIDE

            setenv("FUNCTIONALS_DIR", fullfile(FREESURFER_HOME, "sessions")) ;

        end

    elseif variable_name == "LOCAL_DIR"

        setenv("LOCAL_DIR", fullfile(FREESURFER_HOME, "local")) ;

    else

        error("Unknown FreeSurfer environment variable " + variable_name + ". Aborting…") ;

    end % if

end % function

function freesurfer_env(FREESURFER_HOME, FREESURFER_BIN)
%
% freesurfer_env
%
% A Matlab-implementation of the shell script $FREESURFER_HOME/FreeSurferEnv.sh.
% Makes sure that all relevant environmnt variables and such point to valid
% locations.
%
% Inputs:
%
% - FREESURFER_HOME
%
%   The path to the FreeSurfer installation folder.
%
% - FREESURFER_BIN
%
%   The path to the FreeSurfer binary folder.
%
% Outputs:
%
% - None.
%
%   Throws an error if it turns out the environment varible cannot be set as
%   needed.
%

    arguments

        FREESURFER_HOME (1,1) string { mustBeFolder }

        FREESURFER_BIN (1,1) string { mustBeFolder }

    end

    disp(newline + "Checking environment…")

    % This is the most important variable of them all, so check it here.

    build_stamp_path = fullfile(FREESURFER_HOME, "build-stamp.txt") ;

    if not ( isfile ( build_stamp_path ) )

        warning("The file " + build_stamp_path + " does not exist. Is FreeSurfer installed correctly?" ) ;

    end

    % This environment variable determines whether default directories are to
    % be attempted in case an environment variable is not set.

    FS_OVERRIDE = char ( getenv ( "FS_OVERRIDE" ) );

    if not ( strlength( FS_OVERRIDE ) == 0 )

        FS_OVERRIDE = logical( FS_OVERRIDE ) ;

    else

        FS_OVERRIDE = true ;

    end

    % Go over environment variables.

    env_vars = utilities.fs2zef.FREESURFER_ENV_VARS() ;

    for ii = 1 : numel(env_vars)

        env_var = env_vars(ii) ;

        check_freesurfer_env_variable(env_var, FREESURFER_HOME, FS_OVERRIDE) ;

    end % for

    % Display their values.

    disp ( newline ) ;

    disp ( "FREESURFER_HOME   → " + getenv ( "FREESURFER_HOME" ) ) ;
    disp ( "FSFAST_HOME       → " + getenv ( "FSFAST_HOME" ) ) ;
    disp ( "FSF_OUTPUT_FORMAT → " + getenv ( "FSF_OUTPUT_FORMAT" ) ) ;
    disp ( "SUBJECTS_DIR      → " + getenv ( "SUBJECTS_DIR" ) ) ;
    disp ( "MNI_DIR           → " + getenv ( "MNI_DIR" ) ) ;
    disp ( "FSL_DIR           → " + getenv ( "FSL_DIR" ) ) ;

    %% Set PATH (not to be confused with Matlab path), so that FreeSurfer binaries can be found.

    PATH = string(getenv("PATH"));

    disp(newline + "Adding FreeSurfer binary folder " + FREESURFER_BIN + " to system PATH " + PATH +"…");

    if not ( isfolder( FREESURFER_BIN ) )

        error(newline + "FreeSurfer binaries could not be located in " + FREESURFER_BIN + ". Aborting...");

    end

    if not ( startsWith ( PATH, FREESURFER_BIN ) )

        NEWPATH = fullfile(FREESURFER_HOME, "bin") + ":" + PATH;

    else

        NEWPATH = PATH;

    end

    disp(newline + "PATH set to " + NEWPATH);

    setenv("PATH", NEWPATH);

end % function

function folder = this_folder

    fullpath = mfilename ( "fullpath" ) ;

    [ folder, ~, ~ ] = fileparts ( fullpath ) ;

end
