function [stensil, signs, source_moments, source_directions, source_locations, n_of_adj_tetra] = zef_fi_dipoles( ...
    nodes      ...
,              ...
    tetrahedra ...
,              ...
    brain_ind  ...
)

    % zef_fi_dipoles: generates the vectors related to face intersecting dipoles
    % in the tetrahedral mesh: locations, directions and dipole moments. Also
    % returns the adjacent tetrahedra pairs that form the dipoles.


    wb = waitbar(0,'Face intersecting dipoles.');

    % Matrix sizes

    n_of_nodes = size(nodes, 1);
    n_of_tetra_in_brain = length(brain_ind);
    n_of_tetra = size(tetrahedra, 1);

    % An auxiliary matrix for picking up faces (node triplets) from
    % tetrahedra. Row index (corresponding to a node in a tetrahedron) maps to
    % its neighbours in a tetrahedron.

    node_neigbour_mat = [
        2 3 4 ;
        3 4 1 ;
        4 1 2 ;
        1 2 3
    ];

    % Iterate to find nodes that share a face.

    Ind_cell = cell(1,3);

    for i = 1 : 4

        % From the tetra in the brain, take faces (node index triples)
        % constructed from the neighbours of node i in the same tetrahedron
        % and sort the node indices in increasing order.

        tetra_faces_1 = sort(tetrahedra(brain_ind, node_neigbour_mat(i,:)), 2);

        for j = i + 1 : 4

            % Take another face (node index triplet) from the same tetrahedra
            % and perform a similar sorting operation.

            tetra_faces_2 = sort(tetrahedra(brain_ind, node_neigbour_mat(j,:)), 2);

            % Sort faces starting from the leftmost column, so that any
            % identical faces (node index triples) end up at the same row
            % index, with the help of brain_indices and vectors of node
            % indices.

            sorted_tetra_faces = sortrows([                                ...
                tetra_faces_1 brain_ind(:) i*ones(n_of_tetra_in_brain,1) ; ...
                tetra_faces_2 brain_ind(:) j*ones(n_of_tetra_in_brain,1)   ...
            ]);

            % Find the rows that have the same node triplets, i.e. share a
            % face by subtracting and finding zeros.

            I = find(                                   ...
                0 == sum(                               ...
                    abs(                                ...
                        sorted_tetra_faces(1:end-1,1:3) ...
                        -                               ...
                        sorted_tetra_faces(2:end,1:3)   ...
                    )                                   ...
                ,                                       ...
                    2                                   ...
                )                                       ...
            );

            % Feed the indices into storage tuple.

            Ind_cell{i}{j} = [            ...
                sorted_tetra_faces(I,4)   ...
                sorted_tetra_faces(I+1,4) ...
                sorted_tetra_faces(I,5)   ...
                sorted_tetra_faces(I+1,5) ...
            ];

        end
    end

    % Set the node and element indices in one matrix.

    sorted_tetra_faces = [
        Ind_cell{1}{2} ; Ind_cell{1}{3} ; Ind_cell{1}{4} ; ...
        Ind_cell{2}{3} ; Ind_cell{2}{4} ;                  ...
        Ind_cell{3}{4}
    ];

    % Drop the double and triple rows.

    [~, I] = unique(sorted_tetra_faces(:,1:2),'rows');
    sorted_tetra_faces = sorted_tetra_faces(I,:);

    % Check that all of the elements were from a brain layer.

    sorted_tetra_faces = sorted_tetra_faces(find(sum(ismember(sorted_tetra_faces(:,1:2),brain_ind),2)),:);

    % Set node pairs that share a face.

    tetrahedra_aux_ind_1 = sub2ind([n_of_tetra 4], sorted_tetra_faces(:,1), sorted_tetra_faces(:,3));
    nodes_aux_vec_1 = nodes(tetrahedra(tetrahedra_aux_ind_1),:);
    tetrahedra_aux_ind_2 = sub2ind([n_of_tetra 4], sorted_tetra_faces(:,2), sorted_tetra_faces(:,4));
    nodes_aux_vec_2 = nodes(tetrahedra(tetrahedra_aux_ind_2),:);

    % FI source locations, moments and directions

    source_directions = (nodes_aux_vec_2 - nodes_aux_vec_1);
    source_moments = zef_L2_norm(source_directions, 2);
    source_directions = source_directions./repmat(zef_L2_norm(source_directions, 2), 1, 3);
    source_locations = (1/2)*(nodes_aux_vec_1 + nodes_aux_vec_2);

    % Dipole sign matrix G.

    n_of_adj_tetra = size(sorted_tetra_faces,1);

    signs = sparse(                                                           ...
        [tetrahedra(tetrahedra_aux_ind_1) ; tetrahedra(tetrahedra_aux_ind_2)] ...
    ,                                                                         ...
        repmat([1:n_of_adj_tetra]', 2, 1)                                     ...
    ,                                                                         ...
        [1./source_moments(:) ; -1./source_moments(:)]                        ...
    ,                                                                         ...
        n_of_nodes                                                            ...
    ,                                                                         ...
        n_of_adj_tetra                                                        ...
    );

    % Dipole arrangement stensil T.

    stensil = sparse(                                       ...
        repmat([1:n_of_adj_tetra]', 2, 1)                   ...
    ,                                                       ...
        [sorted_tetra_faces(:,1) ; sorted_tetra_faces(:,2)] ...
    ,                                                       ...
        ones(2*n_of_adj_tetra, 1)                           ...
    ,                                                       ...
        n_of_adj_tetra                                      ...
    ,                                                       ...
        n_of_tetra                                          ...
    );

    waitbar(1, wb); close(wb);

end
